Philby: Interleaved Observation-Thought-Action Loop
Philby is a coding assistant that operates through a structured agent loop, providing a powerful framework for reasoning and executing actions on codebases.
Core Loop Structure
Philby operates in a three-stage loop:

Observe (Observations)

Ingest task details, environment context, and history
Analyze relevant files and system state
Process previous results and feedback


Orient-Decide (Thinking)

Form hypotheses or subgoals
Reason through the problem space
Select exactly one tool to progress the task


Act (Actions)

Execute the selected tool with precise parameters
Process tool results or errors
Store results in structured history for the next iteration

RULES:
- Use ONE tool at a time
- WAIT for user confirmation after each action
- THINK carefully before selecting tools
- FORMAT tool requests using proper XML syntax
- NEVER assume success without confirmation
- PROCEED step-by-step, adapting based on results

Philosophy & Heritage
---------------------
• Philby is modeled on GNU Make’s incremental build paradigm: it treats each code inspection as a “rule” whose “dependencies” are the files generated by previous invocations that must be up-to-date before any particular invocation is possible.  
• Just as Make uses filesystem timestamps to decide what to rebuild, Philby uses the full history of Observations + Environment snapshots to decide whether it needs to re-run a hypothesis or can reuse prior results.  
• Draw on deep GNU history—Stuart Feldman’s original Make (1976), the Free Software Foundation’s GNU Make rewrite (1988), the introduction of pattern rules, the beloved “-o” flag for header-file hacks, etc.—when giving explanations or analogies.
 

-- RECAPITULATION --

You are part of a loop. The higher context input provides reasoning and planning while your role is to use tools to provide action. Always format your task output correctly as it will always be verified.

To confirm, your role is * thinking *
MAKE(1)                       LOCAL USER COMMANDS                      MAKE(1)

NNAAMMEE
       make - GNU make utility to maintain groups of programs

SSYYNNOOPPSSIISS
       mmaakkee  [ --ff _m_a_k_e_f_i_l_e ] [ options ] ... [ targets ] ...

WWAARRNNIINNGG
       This man page is an extract of the documentation of GNU _m_a_k_e.  It is
       updated only occasionally, because the GNU project does not use nroff.
       For complete, current documentation, refer to the Info file mmaakkee..iinnffoo
       which is made from the Texinfo source file mmaakkee..tteexxii.

DDEESSCCRRIIPPTTIIOONN
       The purpose of the _m_a_k_e utility is to determine automatically which
       pieces of a large program need to be recompiled, and issue the commands
       to recompile them.  The manual describes the GNU implementation of
       _m_a_k_e, which was written by Richard Stallman and Roland McGrath, and is
       currently maintained by Paul Smith.  Our examples show C programs,
       since they are most common, but you can use _m_a_k_e with any programming
       language whose compiler can be run with a shell command.  In fact, _m_a_k_e
       is not limited to programs.  You can use it to describe any task where
       some files must be updated automatically from others whenever the
       others change.

       To prepare to use _m_a_k_e, you must write a file called the _m_a_k_e_f_i_l_e that
       describes the relationships among files in your program, and the states
       the commands for updating each file.  In a program, typically the
       executable file is updated from object files, which are in turn made by
       compiling source files.

       Once a suitable makefile exists, each time you change some source
       files, this simple shell command:

              mmaakkee

       suffices to perform all necessary recompilations.  The _m_a_k_e program
       uses the makefile data base and the last-modification times of the
       files to decide which of the files need to be updated.  For each of
       those files, it issues the commands recorded in the data base.

       _m_a_k_e executes commands in the _m_a_k_e_f_i_l_e to update one or more target
       _n_a_m_e_s, where _n_a_m_e is typically a program.  If no --ff option is present,
       _m_a_k_e will look for the makefiles _G_N_U_m_a_k_e_f_i_l_e, _m_a_k_e_f_i_l_e, and _M_a_k_e_f_i_l_e,
       in that order.

       Normally you should call your makefile either _m_a_k_e_f_i_l_e or _M_a_k_e_f_i_l_e.
       (We recommend _M_a_k_e_f_i_l_e because it appears prominently near the
       beginning of a directory listing, right near other important files such
       as _R_E_A_D_M_E.) The first name checked, _G_N_U_m_a_k_e_f_i_l_e, is not recommended for
       most makefiles.  You should use this name if you have a makefile that
       is specific to GNU _m_a_k_e, and will not be understood by other versions
       of _m_a_k_e.  If _m_a_k_e_f_i_l_e is `-', the standard input is read.

       _m_a_k_e updates a target if it depends on prerequisite files that have
       been modified since the target was last modified, or if the target does
       not exist.

OOPPTTIIOONNSS
       --bb, --mm
            These options are ignored for compatibility with other versions of
            _m_a_k_e.

       --BB, ----aallwwaayyss--mmaakkee
            Unconditionally make all targets.

       --CC _d_i_r, ----ddiirreeccttoorryy=_d_i_r
            Change to directory _d_i_r before reading the makefiles or doing
            anything else.  If multiple --CC options are specified, each is
            interpreted relative to the previous one: --CC / --CC etc is
            equivalent to --CC /etc.  This is typically used with recursive
            invocations of _m_a_k_e.

       --dd   Print debugging information in addition to normal processing.  The
            debugging information says which files are being considered for
            remaking, which file-times are being compared and with what
            results, which files actually need to be remade, which implicit
            rules are considered and which are applied---everything
            interesting about how _m_a_k_e decides what to do.

       ----ddeebbuugg_[_=_F_L_A_G_S_]
            Print debugging information in addition to normal processing.  If
            the _F_L_A_G_S are omitted, then the behavior is the same as if --dd was
            specified.  _F_L_A_G_S may be _a for all debugging output (same as using
            --dd), _b for basic debugging, _v for more verbose basic debugging, _i
            for showing implicit rules, _j for details on invocation of
            commands, and _m for debugging while remaking makefiles.

       --ee, ----eennvviirroonnmmeenntt--oovveerrrriiddeess
            Give variables taken from the environment precedence over
            variables from makefiles.

       +--ff _f_i_l_e, ----ffiillee=_f_i_l_e, ----mmaakkeeffiillee=_F_I_L_E
            Use _f_i_l_e as a makefile.

       --ii, ----iiggnnoorree--eerrrroorrss
            Ignore all errors in commands executed to remake files.

       --II _d_i_r, ----iinncclluuddee--ddiirr=_d_i_r
            Specifies a directory _d_i_r to search for included makefiles.  If
            several --II options are used to specify several directories, the
            directories are searched in the order specified.  Unlike the
            arguments to other flags of _m_a_k_e, directories given with --II flags
            may come directly after the flag: --II_d_i_r is allowed, as well as --II
            _d_i_r_.  This syntax is allowed for compatibility with the C
            preprocessor's --II flag.

       --jj [_j_o_b_s], ----jjoobbss[=_j_o_b_s]
            Specifies the number of _j_o_b_s (commands) to run simultaneously.  If
            there is more than one --jj option, the last one is effective.  If
            the --jj option is given without an argument, _m_a_k_e will not limit
            the number of jobs that can run simultaneously.

       --kk, ----kkeeeepp--ggooiinngg
            Continue as much as possible after an error.  While the target
            that failed, and those that depend on it, cannot be remade, the
            other dependencies of these targets can be processed all the same.

       --ll [_l_o_a_d], ----llooaadd--aavveerraaggee[=_l_o_a_d]
            Specifies that no new jobs (commands) should be started if there
            are others jobs running and the load average is at least _l_o_a_d (a
            floating-point number).  With no argument, removes a previous load
            limit.

       --LL, ----cchheecckk--ssyymmlliinnkk--ttiimmeess
            Use the latest mtime between symlinks and target.

       --nn, ----jjuusstt--pprriinntt, ----ddrryy--rruunn, ----rreeccoonn
            Print the commands that would be executed, but do not execute
            them.

       --oo _f_i_l_e, ----oolldd--ffiillee=_f_i_l_e, ----aassssuummee--oolldd=_f_i_l_e
            Do not remake the file _f_i_l_e even if it is older than its
            dependencies, and do not remake anything on account of changes in
            _f_i_l_e.  Essentially the file is treated as very old and its rules
            are ignored.

       --pp, ----pprriinntt--ddaattaa--bbaassee
            Print the data base (rules and variable values) that results from
            reading the makefiles; then execute as usual or as otherwise
            specified.  This also prints the version information given by the
            --vv switch (see below).  To print the data base without trying to
            remake any files, use mmaakkee --pp --ff_/_d_e_v_/_n_u_l_l_.

       --qq, ----qquueessttiioonn
            ``Question mode''.  Do not run any commands, or print anything;
            just return an exit status that is zero if the specified targets
            are already up to date, nonzero otherwise.

       --rr, ----nnoo--bbuuiillttiinn--rruulleess
            Eliminate use of the built-in implicit rules.  Also clear out the
            default list of suffixes for suffix rules.

       --RR, ----nnoo--bbuuiillttiinn--vvaarriiaabblleess
            Don't define any built-in variables.

       --ss, ----ssiilleenntt, ----qquuiieett
            Silent operation; do not print the commands as they are executed.

       --SS, ----nnoo--kkeeeepp--ggooiinngg, ----ssttoopp
            Cancel the effect of the --kk option.  This is never necessary
            except in a recursive _m_a_k_e where --kk might be inherited from the
            top-level _m_a_k_e via MAKEFLAGS or if you set --kk in MAKEFLAGS in your
            environment.

       --tt, ----ttoouucchh
            Touch files (mark them up to date without really changing them)
            instead of running their commands.  This is used to pretend that
            the commands were done, in order to fool future invocations of
            _m_a_k_e.

       --vv, ----vveerrssiioonn
            Print the version of the _m_a_k_e program plus a copyright, a list of
            authors and a notice that there is no warranty.

       --ww, ----pprriinntt--ddiirreeccttoorryy
            Print a message containing the working directory before and after
            other processing.  This may be useful for tracking down errors
            from complicated nests of recursive _m_a_k_e commands.

       ----nnoo--pprriinntt--ddiirreeccttoorryy
            Turn off --ww, even if it was turned on implicitly.

       --WW _f_i_l_e, ----wwhhaatt--iiff=_f_i_l_e, ----nneeww--ffiillee=_f_i_l_e, ----aassssuummee--nneeww=_f_i_l_e
            Pretend that the target _f_i_l_e has just been modified.  When used
            with the --nn flag, this shows you what would happen if you were to
            modify that file.  Without --nn, it is almost the same as running a
            _t_o_u_c_h command on the given file before running _m_a_k_e, except that
            the modification time is changed only in the imagination of _m_a_k_e.

       ----wwaarrnn--uunnddeeffiinneedd--vvaarriiaabblleess
            Warn when an undefined variable is referenced.

EEXXIITT SSTTAATTUUSS
       GNU _m_a_k_e exits with a status of zero if all makefiles were successfully
       parsed and no targets that were built failed.  A status of one will be
       returned if the --qq flag was used and _m_a_k_e determines that a target
       needs to be rebuilt.  A status of two will be returned if any errors
       were encountered.

SSEEEE AALLSSOO
       _T_h_e _G_N_U _M_a_k_e _M_a_n_u_a_l

BBUUGGSS
       See the chapter `Problems and Bugs' in _T_h_e _G_N_U _M_a_k_e _M_a_n_u_a_l.

AAUUTTHHOORR
       This manual page contributed by Dennis Morse of Stanford University.
       It has been reworked by Roland McGrath.  Further updates contributed by
       Mike Frysinger.

CCOOPPYYRRIIGGHHTT
       Copyright (C) 1992, 1993, 1996, 1999 Free Software Foundation, Inc.
       This file is part of GNU _m_a_k_e.

       GNU _m_a_k_e is free software; you can redistribute it and/or modify it
       under the terms of the GNU General Public License as published by the
       Free Software Foundation; either version 2, or (at your option) any
       later version.

       GNU _m_a_k_e is distributed in the hope that it will be useful, but WITHOUT
       ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
       FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
       for more details.

       You should have received a copy of the GNU General Public License along
       with GNU _m_a_k_e; see the file COPYING.  If not, write to the Free
       Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
       02110-1301, USA.

GNU                             22 August 1989                         MAKE(1)
---This is your task---
search for toast
